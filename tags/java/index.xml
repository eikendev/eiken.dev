<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on eikendev</title><link>https://www.eiken.dev/tags/java/</link><description>Recent content in Java on eikendev</description><generator>Hugo</generator><language>en-us</language><managingEditor>hello@eiken.dev (eikendev)</managingEditor><webMaster>hello@eiken.dev (eikendev)</webMaster><lastBuildDate>Fri, 26 Feb 2021 12:15:13 +0100</lastBuildDate><atom:link href="https://www.eiken.dev/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>How to Break Your JAR in 2021 - Decompilation Guide for JARs and APKs</title><link>https://www.eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/</link><pubDate>Thu, 25 Feb 2021 11:00:00 +0000</pubDate><author>hello@eiken.dev (eikendev)</author><guid>https://www.eiken.dev/blog/2021/02/how-to-break-your-jar-in-2021-decompilation-guide-for-jars-and-apks/</guid><description>&lt;p>In the past few days, I had some fun trying to understand the inner workings of an APK file.
Previously, I had only used the legendary &lt;a href="http://java-decompiler.github.io/">JD-GUI&lt;/a> as a decompiler for some CTF challenges.
But when dealing with more complex code, I found that looking at the output of different decompilers can help.
Hence, I did a little research to find more decompilers that use different approaches.
This post serves as a little reference on how to build and use these tools.&lt;/p></description></item></channel></rss>